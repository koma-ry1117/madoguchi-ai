feature: voice-io
title: 音声入出力設計

overview:
  purpose: キオスク端末での音声会話インターフェースを提供し、タイピングが苦手な顧客（特に高齢者）でも快適に物件を探せるようにする
  users: キオスク端末を利用する店舗来店客（認証不要）

goals:
  - 自然な日本語音声認識
  - 高品質な音声合成
  - 低レイテンシーの応答
  - コスト効率の良いキャッシング
  - 高齢者にも使いやすいUI（音声入力ボタンを画面中央に大きく配置）

non_goals:
  - 多言語対応（日本語のみ）
  - リアルタイム字幕生成
  - 音声ファイルのアップロード
  - オペレーター管理画面での音声機能（テキストベースのみ）

technology_stack:
  - layer: Audio Recording
    choice: Web Audio API, MediaRecorder
    role: ブラウザ音声録音
  - layer: STT
    choice: OpenAI Whisper API
    role: 音声→テキスト
  - layer: TTS
    choice: Google Cloud TTS（WaveNet）
    role: テキスト→音声
  - layer: Cache
    choice: Supabase Storage
    role: 音声キャッシュ
  - layer: Audio Playback
    choice: HTML5 Audio API
    role: 音声再生

components:
  frontend:
    - name: VoiceInput
      intent: 音声録音とテキスト変換（キオスク専用）
      requirements: [1]
      ui_design:
        - "音声ボタンは画面中央に大きく配置（120px × 120px以上）"
        - ボタンには「タップしてお話しください」のラベルを表示
        - 録音中は波形アニメーションとカウントダウン表示
        - テキスト入力は補助的な位置（下部に小さく配置）
      state:
        - isRecording: boolean
        - audioBlob: Blob?
        - isProcessing: boolean
        - recordingDuration: number
      props:
        - onTranscribe: "(text: string) => void"
        - disabled: boolean?
        - maxDuration: "number (デフォルト60秒)"
        - size: "'large' | 'medium' (デフォルト'large')"

    - name: AudioPlayer
      intent: ストリーミング音声再生とアバター連携（キオスク専用）
      requirements: [2, 4]
      props:
        - chunks: "string[] # 文単位のチャンク配列"
        - autoPlay: "boolean # キオスクでは常にtrue"
        - onPlayStart: "() => void"
        - onPlayEnd: "() => void"
        - onInterrupt: "() => void # ユーザーが話し始めた時"
        - onSkip: "() => void # スキップボタン押下時"
      state:
        - queue: "AudioBuffer[]"
        - currentIndex: number
        - isPlaying: boolean
        - isSkipped: boolean
      skip_feature:
        - ユーザーが読み上げ中に「スキップ」ボタンを押すと即座に停止
        - 残りのチャンクのTTSリクエストもキャンセル
        - テキストは表示済みなので情報は失われない

    - name: VoiceWaveform
      intent: 録音中の波形表示
      requirements: [1]
      props:
        - analyser: AnalyserNode?
        - isRecording: boolean

streaming_tts:
  design_policy: テキストを先行表示し、音声はバックグラウンドで準備。ユーザーは待ち時間中にテキストを読める
  chunk_splitting:
    method: "日本語の文末で分割（。！？で区切る）"
    example:
      input: "こちらの物件は駅から徒歩5分です。おすすめですよ。"
      output: ["こちらの物件は駅から徒歩5分です。", "おすすめですよ。"]
  audio_queue:
    - "enqueue(audio): チャンクを追加"
    - "play(): 再生開始"
    - "skip(): 読み上げスキップ"

api_routes:
  - path: POST /api/voice/transcribe
    auth: 認証なし（キオスク用）
    request:
      content_type: multipart/form-data
      fields:
        - audio: "File (webm/mp3)"
        - operator_id: string # レート制限用
    response:
      text: string
      duration: number
      language: ja

  - path: POST /api/voice/synthesize
    auth: 認証なし（キオスク用）
    request:
      text: string
      operator_id: uuid
    response:
      content_type: audio/mpeg
      headers:
        X-Cache-Status: "HIT | MISS"

cache:
  key_format: "audio-cache/{operator_id}/{sha256_hash}.mp3"
  storage:
    bucket: audio-cache
    public: false
    max_file_size: 5MB
    allowed_types: [audio/mpeg]
    lifecycle: 30日後自動削除

  precached_phrases:
    purpose: キャッシュヒット率を高め、TTS待ち時間を削減
    categories:
      greetings:
        - いらっしゃいませ。
        - 何かお探しでしょうか？
        - かしこまりました。
        - ありがとうございます。
        - またのご来店をお待ちしております。
      confirmations:
        - ご予算はいくらくらいをお考えですか？
        - 間取りのご希望はありますか？
        - エリアのご希望はありますか？
        - 駅からの距離はどのくらいがよろしいですか？
        - その他にご希望の条件はありますか？
      proposals:
        - こちらの物件はいかがでしょうか。
        - おすすめの物件がございます。
        - 条件に合う物件が見つかりました。
      booking:
        - 内見のご予約を承ります。
        - ご都合の良い日時をお聞かせください。
        - ご連絡先をお教えください。
        - ご予約ありがとうございます。
        - 担当者よりご連絡いたします。
    strategy:
      - 起動時に事前キャッシュフレーズを非同期でTTS生成・保存
      - 文単位のチャンクがキャッシュフレーズと完全一致すればキャッシュヒット
      - キャッシュヒット率をモニタリングし、頻出フレーズを随時追加

error_handling:
  transcription:
    - マイク許可拒否 → テキスト入力にフォールバック、許可を促すメッセージ
    - 録音失敗 → 再試行ボタン表示
    - Whisper APIエラー → テキスト入力を促す
    - 無音検出 → 「お話が聞き取れませんでした」メッセージ
  synthesis:
    - Google Cloud TTS APIエラー → テキストのみ表示（音声なし）
    - キャッシュ保存失敗 → ログ出力（サイレント失敗）
    - 音声再生失敗 → 再生ボタン表示

performance:
  basic_settings:
    - "音声ファイルサイズ: 最大5MB"
    - "録音最大時間: 60秒"
    - "Google Cloud TTS レート制限: operator_idごとにレート制限"
  streaming_optimization:
    - "テキスト先行表示: 音声準備完了を待たずにテキストを即座に表示"
    - "チャンク分割: 文単位で分割し、最初のチャンク準備完了で再生開始"
    - "並列リクエスト: 複数チャンクのTTSを並列で生成"
    - "体感待ち時間: 全文一括より50%以上削減を目標"
  cache_optimization:
    - "キャッシュヒット率の監視（目標: 40%以上）"
    - "事前キャッシュ: よく使うフレーズを起動時にキャッシュ"
    - "文単位キャッシュ: 同じ文は再利用される確率が高い"
  ux_design:
    - "スキップボタン: ユーザーが読み上げをスキップ可能"
    - "音声なしフォールバック: TTS失敗時はテキストのみ表示（情報は失われない）"

testing:
  unit:
    - "VoiceInput: 録音状態管理"
    - "AudioPlayer: 再生コントロール"
    - キャッシュキー生成
  integration:
    - "/api/voice/transcribe: Whisper API呼び出し"
    - "/api/voice/synthesize: Google Cloud TTS + キャッシュ"
  e2e:
    - 録音→変換→AI送信
    - AI応答→音声生成→自動再生
