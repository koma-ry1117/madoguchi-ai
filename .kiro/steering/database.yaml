description: Supabase（PostgreSQL）を使用。Row Level Security（RLS）によるマルチテナント分離。

philosophy:
  - Model the domain first; optimize after correctness
  - RLSでセキュリティを担保、アプリケーション層でバイパス不可
  - Prefer explicit constraints; let database enforce invariants

naming_types:
  tables: snake_case, plural (properties, customers, email_logs)
  columns: snake_case (created_at, operator_id)
  foreign_keys: "{table}_id referencing {table}.id"
  id: UUID (gen_random_uuid())
  timestamps: TIMESTAMPTZ（タイムゾーン付き）
  money: INTEGER（円単位）

core_tables:
  structure: |
    operators（不動産会社）
      ├── properties（物件）
      ├── customers（顧客）
      ├── conversations（会話）
      ├── viewings（内見予約）
      ├── inquiries（問い合わせ）
      └── email_logs（メール送信ログ）
  marketing_email:
    - email_suppressions: 配信停止リスト（バウンス・苦情）
    - marketing_campaigns: キャンペーン管理
    - marketing_campaign_recipients: 配信対象者
    - marketing_email_queue: メールキュー・リトライ

rls_patterns:
  operator_own_data: |
    CREATE POLICY "operator_own_data"
    ON {table} FOR ALL
    TO authenticated
    USING (
      operator_id IN (
        SELECT id FROM operators WHERE user_id = auth.uid()
      )
    );
  customer_own_operator_data: |
    CREATE POLICY "customer_own_operator_data"
    ON {table} FOR SELECT
    TO authenticated
    USING (
      operator_id IN (
        SELECT operator_id FROM customers WHERE user_id = auth.uid()
      )
    );
  admin_all: |
    CREATE POLICY "admin_all"
    ON {table} FOR ALL
    TO authenticated
    USING (
      (SELECT role FROM auth.users WHERE id = auth.uid()) = 'admin'
    );

migrations:
  cli: supabase migration new {name}
  naming: "{timestamp}_{action}_{object} (例: 20250115_add_email_suppressions)"
  note: 本番適用前にローカルでテスト

query_patterns:
  supabase_client: |
    // 自動的にRLSが適用される
    const { data } = await supabase
      .from('properties')
      .select('*')
      .eq('is_public', true);
  complex_query_rpc: |
    -- 営業推奨ユーザー検索
    CREATE FUNCTION get_marketing_recipients(...)
    RETURNS TABLE(...) AS $$
    BEGIN
      -- 配信停止リスト除外
      -- 直近送信済み除外
      -- 条件マッチング
    END;
    $$ LANGUAGE plpgsql SECURITY DEFINER;

indexes:
  principles:
    - FK列には必ずインデックス
    - WHEREで頻繁に使用する列
    - ORDER BYで使用する列
    - 複合インデックスは選択性の高い列を先頭に
  examples:
    - CREATE INDEX idx_properties_operator_id ON properties(operator_id);
    - CREATE INDEX idx_email_logs_status_sent_at ON email_logs(status, sent_at DESC);

data_integrity:
  - NOT NULLを積極的に使用
  - CHECK制約でenum値を制限
  - UNIQUE制約で重複防止
  - カスケード削除は慎重に（ON DELETE CASCADE vs SET NULL）
